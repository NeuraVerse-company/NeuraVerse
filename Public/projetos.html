<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interface de IA</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000000; /* Preto tecnol√≥gico */
            overflow: hidden;
            position: relative;
        }
        #main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 1;
        }
        #neural-network {
            width: 200px;
            height: 100px;
            background: transparent;
        }
        #avatar-container {
            display: flex;
            flex-direction: row;
            gap: 50px;
        }
        .avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #343541;
            border: 3px solid #0078d4; /* Borda azul para todos os avatares */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #ai-avatar {
            border-color: #0078d4; /* Azul para IA */
        }
        #user-avatar {
            border-color: #0078d4; /* Azul para usu√°rio */
        }
        #mic-button {
            padding: 10px;
            background-color: #0078d4;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #mic-button.listening {
            background-color: #ff4444;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <canvas id="neural-network"></canvas>
        <div id="avatar-container">
            <div class="avatar" id="ai-avatar">
                <img src="https://via.placeholder.com/100?text=IA" alt="Modelo de IA">
            </div>
            <div class="avatar" id="user-avatar">
                <img src="https://via.placeholder.com/100?text=Usu√°rio" alt="Usu√°rio">
            </div>
        </div>
        <button id="mic-button">üé§</button>
    </div>

    <script src="https://aka.ms/csspeech/jsbrowserpackage"></script>
    <script>
        const { SpeechConfig, AudioConfig, SpeechRecognizer } = window.SpeechSDK;

        // Configura√ß√µes do Azure Speech Service (apenas para reconhecimento de voz)
        const subscriptionKey = "SUA_CHAVE_DO_AZURE_SPEECH"; // Substitua pela sua chave do Speech Service
        const region = "SUA_REGIAO"; // Exemplo: "eastus"
        const speechConfig = SpeechConfig.fromSubscription(subscriptionKey, region);
        speechConfig.speechRecognitionLanguage = "pt-BR";

        // Elemento da interface
        const micButton = document.getElementById("mic-button");
        let recognizer = null;
        let isListening = false;
        let isProcessing = false; // Estado para controlar a visibilidade do tri√¢ngulo

        // Configurar o canvas para a rede neural estilizada
        const canvas = document.getElementById("neural-network");
        canvas.width = 200;
        canvas.height = 100;
        const ctx = canvas.getContext("2d");

        // Definir os n√≥s no formato de um tri√¢ngulo menor e mais compacto com tons de azul
        const nodes = [
            { x: 100, y: 30, color: "#1E90FF" }, // Topo do tri√¢ngulo
            { x: 80, y: 60, color: "#00BFFF" },  // Canto inferior esquerdo
            { x: 120, y: 60, color: "#4682B4" }  // Canto inferior direito
        ];

        // Definir conex√µes para formar o tri√¢ngulo
        const connections = [
            { start: 0, end: 1 }, // Topo para canto inferior esquerdo
            { start: 1, end: 2 }, // Canto inferior esquerdo para canto inferior direito
            { start: 2, end: 0 }  // Canto inferior direito para topo
        ];

        // Vari√°veis para anima√ß√£o
        let time = 0;
        const neuronSpeed = 0.02; // Velocidade do "neur√¥nio" (c√≠rculo em movimento)
        const neuronPositions = connections.map(() => ({ t: 0, direction: 1 })); // Posi√ß√£o e dire√ß√£o de cada "neur√¥nio"

        // Fun√ß√£o de anima√ß√£o
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpar o canvas

            if (isProcessing) {
                time += 0.05; // Incremento de tempo para anima√ß√£o suave

                // Desenhar os "neur√¥nios" (c√≠rculos em movimento) entre os n√≥s
                connections.forEach((connection, index) => {
                    const startNode = nodes[connection.start];
                    const endNode = nodes[connection.end];
                    const pos = neuronPositions[index];

                    // Atualizar a posi√ß√£o do "neur√¥nio"
                    pos.t += neuronSpeed * pos.direction;
                    if (pos.t >= 1) {
                        pos.t = 1;
                        pos.direction = -1; // Inverter dire√ß√£o ao chegar no destino
                    } else if (pos.t <= 0) {
                        pos.t = 0;
                        pos.direction = 1; // Inverter dire√ß√£o ao voltar ao in√≠cio
                    }

                    // Calcular a posi√ß√£o interpolada do "neur√¥nio"
                    const x = startNode.x + (endNode.x - startNode.x) * pos.t;
                    const y = startNode.y + (endNode.y - startNode.y) * pos.t;

                    // Desenhar o "neur√¥nio" (pequeno c√≠rculo branco)
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2); // C√≠rculo pequeno de raio 2
                    ctx.fillStyle = "#ffffff";
                    ctx.fill();
                });

                // Desenhar n√≥s como c√≠rculos em tons de azul pulsantes (maiores)
                nodes.forEach((node, index) => {
                    const pulse = Math.sin(time + index) * 1 + 5; // Tamanho pulsante entre 4 e 6
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, pulse, 0, Math.PI * 2);
                    ctx.fillStyle = node.color; // Cor do n√≥ em tom de azul
                    ctx.fill();
                });
            }

            requestAnimationFrame(animate); // Loop de anima√ß√£o
        }

        // Iniciar a anima√ß√£o
        animate();

        // Iniciar reconhecimento cont√≠nuo automaticamente
        function startContinuousRecognition() {
            const audioConfig = AudioConfig.fromDefaultMicrophoneInput();
            recognizer = new SpeechRecognizer(speechConfig, audioConfig);

            micButton.classList.add("listening");
            isListening = true;

            recognizer.recognized = (s, e) => {
                if (e.result.reason === SpeechSDK.ResultReason.RecognizedSpeech) {
                    const userInput = e.result.text;
                    if (!isProcessing) { // S√≥ processar uma nova pergunta se n√£o estiver processando
                        isProcessing = true; // Mostrar o tri√¢ngulo quando uma pergunta √© reconhecida
                        processInput(userInput);
                    }
                }
            };

            recognizer.canceled = (s, e) => {
                console.error("Reconhecimento cancelado:", e.errorDetails);
                stopContinuousRecognition();
            };

            recognizer.sessionStopped = () => {
                stopContinuousRecognition();
            };

            recognizer.startContinuousRecognitionAsync();
        }

        // Parar reconhecimento cont√≠nuo (apenas para limpeza ou erro)
        function stopContinuousRecognition() {
            if (recognizer) {
                recognizer.stopContinuousRecognitionAsync(
                    () => {
                        recognizer.close();
                        recognizer = null;
                        micButton.classList.remove("listening");
                        isListening = false;
                    },
                    (error) => {
                        console.error("Erro ao parar o reconhecimento:", error);
                    }
                );
            }
        }

        // Fun√ß√£o para processar a entrada com Azure OpenAI
        async function processInput(input) {
            const apiKey = "SUA_CHAVE_OPENAI_AZURE"; // Substitua pela sua chave do Azure OpenAI
            const endpoint = "SEU_ENDPOINT_OPENAI"; // Exemplo: "https://<seu-recurso>.openai.azure.com/"
            const deployment = "SEU_DEPLOYMENT_NAME"; // Nome do deployment no Azure OpenAI
            const url = `${endpoint}/openai/deployments/${deployment}/chat/completions?api-version=2023-05-15`;

            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "api-key": apiKey
                    },
                    body: JSON.stringify({
                        messages: [
                            { role: "system", content: "Voc√™ √© um assistente √∫til." },
                            { role: "user", content: input }
                        ],
                        max_tokens: 150,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    throw new Error("Erro na resposta da API");
                }

                const data = await response.json();
                const aiResponse = data.choices[0].message.content.trim();
                speakResponse(aiResponse);
            } catch (error) {
                console.error(error);
                speakResponse("Desculpe, houve um erro ao processar sua solicita√ß√£o.");
            }
        }

        // Fun√ß√£o para falar a resposta com ElevenLabs
        async function speakResponse(text) {
            const elevenLabsApiKey = "SUA_CHAVE_ELEVENLABS"; // Substitua pela sua chave do ElevenLabs
            const voiceId = "SEU_VOICE_ID"; // Substitua pelo ID da voz do ElevenLabs
            const url = `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}/stream`;

            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "xi-api-key": elevenLabsApiKey
                    },
                    body: JSON.stringify({
                        text: text,
                        model_id: "eleven_multilingual_v2",
                        voice_settings: {
                            stability: 0.5,
                            similarity_boost: 0.5
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error("Erro na resposta do ElevenLabs");
                }

                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                audio.play();
                audio.onplay = () => {
                    isProcessing = false; // Esconder o tri√¢ngulo quando o √°udio come√ßar a tocar
                };
            } catch (error) {
                console.error(error);
                isProcessing = false; // Esconder o tri√¢ngulo em caso de erro
            }
        }

        // Iniciar o reconhecimento automaticamente ao carregar a p√°gina
        startContinuousRecognition();
    </script>
</body>
</html>